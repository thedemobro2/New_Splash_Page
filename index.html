<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RETRO TERMINAL — The Rebel Library</title>
  <style>
    :root{
      --bg:#020b05;
      --glow:#2bff63;
      --glow2:#19c84a;
      --dim:#0b3a1b;
      --scan: rgba(0,0,0,.18);
      --noise: rgba(255,255,255,.03);
      --frame:#0a140d;
      --frame2:#0e2214;
      --warn:#ffd54a;
      --err:#ff4d6d;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    html,body{height:100%; margin:0; background:#000;}
    body{
      display:grid;
      place-items:center;
      background:
        radial-gradient(1200px 700px at 30% 20%, rgba(43,255,99,.15), transparent 60%),
        radial-gradient(900px 600px at 70% 80%, rgba(25,200,74,.10), transparent 55%),
        linear-gradient(180deg, #020202, #000);
      color:var(--glow);
    }

    .rig{
      width:min(980px, 94vw);
      height:min(620px, 84vh);
      position:relative;
      border-radius:18px;
      padding:18px;
      background: linear-gradient(180deg, rgba(14,34,20,.75), rgba(6,10,7,.9));
      box-shadow:
        0 30px 120px rgba(0,0,0,.7),
        inset 0 0 0 2px rgba(43,255,99,.12),
        inset 0 0 0 8px rgba(0,0,0,.25);
    }

    .bezel{
      height:100%;
      border-radius:14px;
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.82));
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.03);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
      position:relative;
      overflow:hidden;
    }

    .badge{
      position:absolute;
      top:10px;
      right:14px;
      font-size:12px;
      letter-spacing:.12em;
      color:rgba(255,255,255,.25);
      user-select:none;
    }

    .screen{
      flex:1;
      border-radius:10px;
      background:
        radial-gradient(800px 520px at 50% 30%, rgba(43,255,99,.12), transparent 62%),
        linear-gradient(180deg, rgba(2,11,5,.96), rgba(0,0,0,.98));
      box-shadow:
        inset 0 0 0 1px rgba(43,255,99,.18),
        inset 0 0 40px rgba(0,0,0,.65);
      position:relative;
      overflow:hidden;
    }

    /* CRT overlays */
    .screen::before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,.00) 0px,
          rgba(0,0,0,.00) 2px,
          rgba(0,0,0,.18) 3px
        );
      mix-blend-mode:multiply;
      pointer-events:none;
      opacity:.55;
    }
    .screen::after{
      content:"";
      position:absolute; inset:-40px;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,.05), transparent 45%),
        radial-gradient(circle at 70% 80%, rgba(255,255,255,.03), transparent 40%),
        repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,.02) 0 1px, transparent 1px 6px);
      filter: blur(.2px);
      pointer-events:none;
      opacity:.65;
    }

    .output{
      position:absolute; inset:0;
      padding:18px 18px 56px;
      overflow:auto;
      white-space:pre-wrap;
      line-height:1.35;
      text-shadow: 0 0 10px rgba(43,255,99,.28);
      scrollbar-width:thin;
      scrollbar-color: rgba(43,255,99,.25) transparent;
    }

    .output::-webkit-scrollbar{width:10px;}
    .output::-webkit-scrollbar-thumb{background: rgba(43,255,99,.18); border-radius:10px;}
    .output::-webkit-scrollbar-track{background: transparent;}

    .statusbar{
      position:absolute; left:0; right:0; bottom:0;
      height:44px;
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.85));
      border-top: 1px solid rgba(43,255,99,.15);
      display:flex;
      align-items:center;
      padding:0 14px;
      gap:12px;
      user-select:none;
    }

    .led{
      width:10px; height:10px; border-radius:50%;
      background: rgba(43,255,99,.25);
      box-shadow: 0 0 12px rgba(43,255,99,.25);
    }
    .led.on{
      background: rgba(43,255,99,.95);
      box-shadow: 0 0 18px rgba(43,255,99,.8);
    }

    .hint{
      color: rgba(43,255,99,.65);
      font-size:12px;
      letter-spacing:.02em;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      flex:1;
    }

    .kbd{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      color: rgba(255,255,255,.25);
    }

    .keycap{
      border:1px solid rgba(255,255,255,.08);
      padding:4px 8px;
      border-radius:8px;
      background: rgba(255,255,255,.03);
    }

    .prompt{
      position:absolute;
      left:18px; right:18px; bottom:56px;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:10px;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(43,255,99,.16);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }

    .ps1{
      color: rgba(43,255,99,.9);
      user-select:none;
    }

    input{
      flex:1;
      background: transparent;
      border:0;
      outline:none;
      color: var(--glow);
      font: inherit;
      caret-color: var(--glow);
      text-shadow: 0 0 10px rgba(43,255,99,.28);
    }

    .cursor{
      width:10px;
      height:16px;
      background: rgba(43,255,99,.9);
      animation: blink 1.1s steps(1) infinite;
      box-shadow: 0 0 12px rgba(43,255,99,.4);
    }
    @keyframes blink { 50% { opacity:0; } }

    .dim{ color: rgba(43,255,99,.55); }
    .warn{ color: var(--warn); text-shadow: 0 0 10px rgba(255,213,74,.25); }
    .err{ color: var(--err); text-shadow: 0 0 10px rgba(255,77,109,.25); }

    /* “Power-on” flicker */
    .flicker{ animation: flicker 1.4s linear 1; }
    @keyframes flicker{
      0%{ filter: brightness(.15) contrast(1.2); }
      10%{ filter: brightness(.8) contrast(1.2); }
      16%{ filter: brightness(.2) contrast(1.2); }
      22%{ filter: brightness(1) contrast(1.2); }
      28%{ filter: brightness(.4) contrast(1.2); }
      34%{ filter: brightness(1) contrast(1.2); }
      100%{ filter: none; }
    }

    @media (max-width:520px){
      .rig{ height: 86vh; }
      .badge{ display:none; }
      .kbd{ display:none; }
    }
  </style>
</head>
<body>
  <div class="rig">
    <div class="bezel">
      <div class="badge">MODEL RL-80 • ROM v1.9</div>
      <div class="screen flicker" id="screen">
        <div class="output" id="out" aria-live="polite"></div>

        <div class="prompt" role="group" aria-label="terminal input">
          <div class="ps1" id="ps1">A:\></div>
          <input id="in" autocomplete="off" spellcheck="false" />
          <div class="cursor" aria-hidden="true"></div>
        </div>

        <div class="statusbar">
          <div class="led" id="led"></div>
          <div class="hint" id="hint">Press ENTER. Try: HELP, DIR, RUN REBEL</div>
          <div class="kbd">
            <span class="keycap">ESC</span>
            <span class="keycap">ENTER</span>
            <span class="keycap">↑</span>
            <span class="keycap">↓</span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== CONFIG YOU SHOULD EDIT ======
  const ROUTE_URL = "https://example.com"; // <-- set to your real domain (or /home etc.)
  const ROUTE_DELAY_MS = 1500; // delay after the finale before redirect
  const BRAND = "THE REBEL LIBRARY";
  // ===================================

  const out = document.getElementById("out");
  const input = document.getElementById("in");
  const ps1 = document.getElementById("ps1");
  const hint = document.getElementById("hint");
  const led = document.getElementById("led");

  const state = {
    mode: "shell",     // shell | rebel
    step: 0,           // rebel flow step
    history: [],
    histIdx: 0,
    cwd: "A:\\",
    awaitingKey: null, // for puzzle prompts
  };

  // Utility: print with optional typewriter feel
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function scrollBottom(){ out.scrollTop = out.scrollHeight; }

  async function typeLine(text="", cls=""){
    // cls can be "dim warn err" etc. (we embed spans)
    const line = document.createElement("div");
    if (cls) line.className = cls;
    out.appendChild(line);

    // typewriter: per char
    for (const ch of text){
      line.textContent += ch;
      scrollBottom();
      await sleep(4); // tweak speed here
    }
    scrollBottom();
  }

  function instantLine(html){
    const line = document.createElement("div");
    line.innerHTML = html;
    out.appendChild(line);
    scrollBottom();
  }

  function prompt(){
    ps1.textContent = state.cwd + ">";
    input.value = "";
    input.focus();
  }

  function setHint(t){ hint.textContent = t; }
  function setLed(on){ led.classList.toggle("on", !!on); }

  function normalize(cmd){
    return cmd.trim().replace(/\s+/g," ");
  }

  // Fake filesystem
  const files = {
    "README.TXT": [
      "RL-80 PERSONAL MICROCOMPUTER",
      "---------------------------",
      "Type HELP for commands.",
      "To begin: RUN REBEL",
      "",
      "Note: Some knowledge prefers shadows."
    ],
    "REBEL.TXT": [
      "THE REBEL LIBRARY",
      "A collection of forbidden footnotes,",
      "misfiled myths, and brave little truths.",
      "",
      "To enter: RUN REBEL"
    ],
    "DIALUP.BAT": [
      "@ECHO OFF",
      "ATDT 9,1,555-REBL",
      "CONNECT 2400",
      "GOTO:ELSEWHERE"
    ]
  };

  function dirListing(){
    return [
      " Volume in drive A is RL80_BOOT",
      " Volume Serial Number is 19C0-1984",
      "",
      " Directory of A:\\",
      "",
      "README   TXT     1,024  12-31-85  12:00a",
      "REBEL    TXT     2,048  12-31-85  12:00a",
      "DIALUP   BAT       512  12-31-85  12:00a",
      "REBEL    EXE    34,816  12-31-85  12:00a",
      "",
      "     4 File(s)         38,400 bytes",
      "     0 Dir(s)          81,920 bytes free"
    ];
  }

  async function bootSequence(){
    setLed(true);
    out.innerHTML = "";
    setHint("Booting...");
    await typeLine("RL-80 BIOS v1.9 (C) 1985 REBELWORKS", "dim");
    await sleep(120);
    await typeLine("64K RAM SYSTEM  64K RAM FREE", "dim");
    await sleep(120);
    await typeLine("Detecting drives... A: OK   B: NOT PRESENT", "dim");
    await sleep(120);
    await typeLine("Loading COMMAND.COM", "dim");
    await sleep(180);
    await typeLine("");
    await typeLine("Welcome to RL-DOS 2.1");
    await typeLine("Type HELP for a list of commands.");
    await typeLine("");
    setLed(false);
    setHint("Try: DIR  |  TYPE REBEL.TXT  |  RUN REBEL");
    prompt();
  }

  // SHELL COMMANDS
  async function handleShell(cmdRaw){
    const cmd = normalize(cmdRaw);
    if (!cmd) return;

    state.history.push(cmd);
    state.histIdx = state.history.length;

    // echo command
    instantLine(`<span class="dim">${state.cwd}&gt;</span> ${escapeHtml(cmd)}`);

    const [head, ...rest] = cmd.split(" ");
    const arg = rest.join(" ").toUpperCase();

    switch (head.toUpperCase()){
      case "HELP":
        await typeLine("Commands:", "dim");
        await typeLine("  HELP               show this help", "dim");
        await typeLine("  DIR                list files", "dim");
        await typeLine("  TYPE <FILE>        print a file", "dim");
        await typeLine("  RUN REBEL          start The Rebel Library", "dim");
        await typeLine("  CLS                clear screen", "dim");
        await typeLine("  BOOT               reboot", "dim");
        setHint("Pro tip: RUN REBEL");
        break;

      case "DIR":
        for (const l of dirListing()) await typeLine(l, "dim");
        setHint("Try: TYPE REBEL.TXT or RUN REBEL");
        break;

      case "TYPE":
        if (!arg){ await typeLine("TYPE requires a filename.", "err"); break; }
        if (!files[arg]){
          await typeLine(`File not found: ${arg}`, "err");
          break;
        }
        for (const l of files[arg]) await typeLine(l);
        setHint("If you’re ready: RUN REBEL");
        break;

      case "RUN":
        if (arg !== "REBEL" && arg !== "REBEL.EXE"){
          await typeLine("Bad command or file name.", "err");
          break;
        }
        await startRebel();
        break;

      case "CLS":
        out.innerHTML = "";
        setHint("Clean slate. RUN REBEL when ready.");
        break;

      case "BOOT":
        await bootSequence();
        break;

      default:
        await typeLine("Bad command or file name.", "err");
        setHint("Try HELP");
    }
  }

  // REBEL EXPERIENCE (interactive story + puzzles)
  async function startRebel(){
    state.mode = "rebel";
    state.step = 0;
    state.awaitingKey = null;
    setLed(true);
    setHint("THE REBEL LIBRARY loading...");
    await typeLine("");
    await typeLine("Loading REBEL.EXE ...", "dim");
    await sleep(250);
    await typeLine("Initializing clandestine stacks...", "dim");
    await sleep(250);
    await typeLine("");
    setLed(false);
    await rebelNext();
  }

  async function rebelNext(userAnswer){
    // If userAnswer provided, validate based on step.
    if (typeof userAnswer === "string") {
      const a = normalize(userAnswer).toUpperCase();
      const ok = validateRebelAnswer(state.step, a);
      if (!ok.ok){
        await typeLine(ok.msg, "err");
        setHint("Try again. (ESC to exit)");
        return;
      }
      // advance if ok
      state.step++;
    }

    const s = state.step;

    if (s === 0){
      await typeLine(`${BRAND}`, "warn");
      await typeLine("================================", "dim");
      await typeLine("");
      await typeLine("A terminal blinks like it knows your name.");
      await typeLine("It wants a password.");
      await typeLine("");
      await typeLine("Hint: It's written on the disk label.");
      state.awaitingKey = "PASS";
      setHint("Enter password:");
      return;
    }

    if (s === 1){
      await typeLine("");
      await typeLine("ACCESS GRANTED.", "warn");
      await typeLine("Welcome, Archivist.");
      await typeLine("");
      await typeLine("A librarian (unpaid, unafraid) slides a note under the cursor:");
      await typeLine("\"The shelves rearrange when you tell the truth.\"");
      await typeLine("");
      await typeLine("Puzzle 1: Choose a door: [A]lgebra, [B]inary, [C]rypt.");
      state.awaitingKey = "DOOR";
      setHint("Type A, B, or C:");
      return;
    }

    if (s === 2){
      await typeLine("");
      await typeLine("You step into a narrow hall of humming modems.");
      await typeLine("A bulletin board scrolls a riddle:");
      await typeLine("");
      await typeLine("  'I speak in 1s and 0s, but I am not a machine.'", "dim");
      await typeLine("  'Name me.'", "dim");
      state.awaitingKey = "RIDDLE";
      setHint("Your answer:");
      return;
    }

    if (s === 3){
      await typeLine("");
      await typeLine("Correct. The hall approves with a soft relay-click.");
      await typeLine("");
      await typeLine("Puzzle 2: A file cabinet asks for a 4-digit code.");
      await typeLine("Hint: The year this machine thinks it is.");
      state.awaitingKey = "CODE";
      setHint("Enter 4 digits:");
      return;
    }

    if (s === 4){
      await typeLine("");
      await typeLine("CABINET UNLOCKED.", "warn");
      await typeLine("Inside: a map made of margins.");
      await typeLine("It points to a single command:");
      await typeLine("");
      await typeLine("  DIAL", "dim");
      await typeLine("");
      await typeLine("Type DIAL to connect, or ESC to return to DOS.");
      state.awaitingKey = "DIAL";
      setHint("Type DIAL:");
      return;
    }

    if (s === 5){
      await finaleAndRoute();
      return;
    }
  }

  function validateRebelAnswer(step, answer){
    // Step 0 expects password on disk label: "RL80"
    if (step === 0){
      if (answer === "RL80" || answer === "RL-80") return {ok:true};
      return {ok:false, msg:"ACCESS DENIED. (Hint: try RL80)"};
    }
    // Step 1 door: Binary is best
    if (step === 1){
      if (["B","BINARY"].includes(answer)) return {ok:true};
      return {ok:false, msg:"That door is locked. The humming prefers Binary (B)."};
    }
    // Step 2 riddle: "language" (or "code") style answer
    if (step === 2){
      if (["LANGUAGE","A LANGUAGE","CODE","A CODE"].includes(answer)) return {ok:true};
      return {ok:false, msg:"Not quite. Think: humans speak it. Machines read it."};
    }
    // Step 3 code year: 1985 per our directory timestamps
    if (step === 3){
      if (answer === "1985") return {ok:true};
      return {ok:false, msg:"Incorrect. Check the file dates. This box lives in 1985."};
    }
    // Step 4 expects DIAL
    if (step === 4){
      if (answer === "DIAL") return {ok:true};
      return {ok:false, msg:"The modem just stares. Type DIAL."};
    }
    return {ok:true};
  }

  async function finaleAndRoute(){
    setLed(true);
    setHint("Dialing...");
    await typeLine("");
    await typeLine("ATDT 9,1,555-REBL", "dim");
    await sleep(250);
    await typeLine("CONNECT 2400", "warn");
    await sleep(300);
    await typeLine("");
    await typeLine("A distant server answers like a lighthouse with opinions.");
    await typeLine("Transferring you to the modern stacks...", "dim");
    await sleep(ROUTE_DELAY_MS);

    // “authentic” routing: replace location
    window.location.replace(ROUTE_URL);
  }

  // Input handling
  function escapeHtml(s){
    return s.replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  input.addEventListener("keydown", async (e) => {
    // History in shell mode
    if (state.mode === "shell"){
      if (e.key === "ArrowUp"){
        e.preventDefault();
        state.histIdx = Math.max(0, state.histIdx - 1);
        input.value = state.history[state.histIdx] ?? "";
        return;
      }
      if (e.key === "ArrowDown"){
        e.preventDefault();
        state.histIdx = Math.min(state.history.length, state.histIdx + 1);
        input.value = state.history[state.histIdx] ?? "";
        return;
      }
    }

    // ESC always exits rebel back to shell
    if (e.key === "Escape"){
      if (state.mode === "rebel"){
        instantLine(`<span class="dim">[ESC]</span> Returning to DOS...`);
        state.mode = "shell";
        state.awaitingKey = null;
        setLed(false);
        setHint("Back at DOS. Try: RUN REBEL");
        prompt();
      }
      return;
    }

    if (e.key !== "Enter") return;
    e.preventDefault();

    const value = input.value;

    if (state.mode === "shell"){
      await handleShell(value);
      prompt();
      return;
    }

    // rebel mode
    if (state.mode === "rebel"){
      if (!normalize(value)){
        setHint("Type something. (ESC to exit)");
        return;
      }
      // echo input (like terminal)
      instantLine(`<span class="dim">REBEL&gt;</span> ${escapeHtml(value)}`);
      const awaiting = state.awaitingKey;
      input.value = "";

      if (!awaiting){
        setHint("...");
        return;
      }

      // Validate answer at current step
      await rebelNext(value);
      return;
    }
  });

  // Click-to-focus anywhere
  document.getElementById("screen").addEventListener("mousedown", () => input.focus());

  // Kickoff
  bootSequence();
})();
</script>
</body>
</html>
